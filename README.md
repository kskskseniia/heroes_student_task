## Heroes Battle

### Алгоритмы:

---

#### SuitableForAttackUnitsFinderImpl — поиск доступных целей для атаки

Метод получает юнитов противника, сгруппированных по рядам (`unitsByRow`, всего 3 ряда).
Внутри каждого ряда все юниты имеют одинаковую координату `y`, поэтому “прикрытие” определяется
по горизонтали — по координате `x`: доступной целью считается только “крайний” живой юнит по координате x, 
за которым нет других юнитов в направлении атаки (слева или справа в зависимости от атакующей армии). 

**Сложность по времени:**
- один проход по всем юнитам в `unitsByRow`: `O(n)`,
- итого `O(n)` (так как количество рядов фиксировано и равно 3).
---

#### GeneratePresetImpl — генерация армии компьютера

Алгоритм использует жадный подход: типы юнитов сортируются по эффективности
(сначала `baseAttack/cost`, затем `health/cost`, и если этого не хватило то по `baseAttack`), 
после чего для каждого типа добавляется до 11 юнитов, пока хватает `maxPoints`. 
Размещение выполняется на стороне компьютера (x=0..2, y=0..20) в случайные свободные клетки.

**Сложность по времени:**
- сортировка типов: `O(n log n)`,
- добавление юнитов: `O(m)`, 
- итого `O(n log n + m)`.

---

#### UnitTargetPathFinderImpl — поиск кратчайшего пути до цели

Для поиска кратчайшего пути используется обход в ширину (BFS): начиная со старта, алгоритм
постепенно расширяет фронт поиска, посещая клетки в порядке увеличения расстояния. Для
восстановления маршрута сохраняется предшественник каждой посещённой клетки, после чего
путь восстанавливается от цели к старту и разворачивается.

Если маршрут невозможен (цель полностью заблокирована препятствиями), метод возвращает
пустой список.

**Сложность по времени:**
- построение карты препятствий: `O(n)` (где `n` — число юнитов в `existingUnitList`),
- BFS по полю: `O(WIDTH · HEIGHT)`,
- итого `O(WIDTH · HEIGHT)`.

---

#### SimulateBattleImpl — симуляция пошагового боя

Алгоритм реализует симуляцию боя раундами. В начале каждого раунда из обеих армий
выбираются только живые юниты и формируются очереди хода: юниты сортируются по убыванию
`baseAttack` (при равенстве — по `health`, затем по `name`, чтобы порядок был стабильным).
Далее ходы выполняются по очереди: компьютер → игрок → компьютер → игрок, пока не закончатся
очереди на текущий раунд. Если юнит погиб до своего хода (`isAlive = false`), он пропускается и
фактически исключается из очереди. Атака выполняется через `attacker.getProgram().attack()`,
после каждого хода печатается лог `printBattleLog.printBattleLog(attacker, target)`.

**Сложность по времени:**
- на каждом раунде: фильтрация живых + сортировка очередей: `O(n log n)`,
- число раундов в худшем случае: `O(n)`,
- итого `O(n^2 log n)` (при условии, что `attack()` работает за `O(1)`).
